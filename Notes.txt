Start of document.


Qt serial port (add on) component information:
  * http://qt-project.org/wiki/QtSerialPort#7868ff75ba2ba6671f178bc8fb7da0fd
    o Get the source code: git clone git://gitorious.org/qt/qtserialport.git
  * Requires 'libudev-dev' on Ubuntu.
  * Qt install location: /usr/share/qt4/
  * Qt documentation install location: /usr/share/qt4/doc/
    o /usr/share/qt4/doc/qch/qt.qch
  * Documentation requires Qt html help, which is normally found in
    'ftp://ftp.trolltech.com/qt/source/qt-everywhere-opensource-src-4.8.1.tar.gz', but can usually also be installed
    with the system package manager.
    o # sudo apt-get install qt4-doc-html
    o 'qt.index' will be installed at '/usr/share/qt4/doc/html/qt.index'.
    o Follow documentation build instructions.
    o # sudo cp html/SerialPort.qch /usr/share/qt4/doc/qch/
    o Run QtCreator->Tools->Options->Help->Add and add '/usr/share/qt4/doc/SerialPort.qch'.

* To detect which version of Qt 4 is installed, inspect the values of macros
  'QT_VERSION' and 'QT_VERSION_STR' in '/usr/share/qt4/include/Qt/qglobal.h'.
  o Find the Qt source tree root:
    # find /usr -name 'qglobal.h' | grep '/Qt/' | sed 's:Qt/qglobal.h::g'
  o Find the Qt library version:
    # grep QT_VERSION_STR $(find /usr -name 'qglobal.h' | grep '/Qt/') | awk '{print $3;}' | sed 's/"//g'
  o See also: http://lists.trolltech.com/qt-interest/2001-03/thread00026-0.html
  o 'qVersion()' can be used by Qt applications.

* Signal methods should *not* be implemented, only declared.  Implementation is generated by qmake (moc).

* Qt Documentation: "Threads and Implicitly Shared Classes":
  http://harmattan-dev.nokia.com/docs/library/html/qt4/threads-modules.html
  http://harmattan-dev.nokia.com/docs/library/html/qt4/threads-reentrancy.html
  "... QString is reentrant but not thread-safe.
   You can safely access different instances of QString from multiple threads simultaneously,
   but you can't safely access the same instance of QString from multiple threads simultaneously
   (unless you protect the accesses yourself with a QMutex)."
   "Beginning with Qt 4, implicit shared classes can safely be copied across threads,
    like any other value classes. They are fully reentrant."  NOT THREAD SAFE!!!
   Bottom line: clone QString's when passing across synchronization domain boundaries!

* See: http://huntharo.com/2009/08/qthread-signalsslots-why-your-calls-stay-in-the-main-thread/
  "Inform Qt that 'this' object is owned by the OS thread it encapsulates.
   This ensures that signals/slots and QEvents are passed between threads and
   executed (asynchronously) in the appropriate context.
   'moveToThread(QThread *)' can only /push/ an object from the current OS thread to the
   OS thread implemented by its argument.  It cannot /pull/ a QObject from one OS thread to another,
   which is why this method is called here and *not* in 'run()'."


* Use 0x01/0x81 to receive the GAT version number and calculation state machine status.
* Initiate authentications with 0x04/0x84 and read back results with 0x03/0x83.
* Use 0x02/0x82 to determine when the last auth results were calculated, if any.


[TASK LIST]
-----------
[x] It makes more sense to use CGatHostCmd derivatives as arguments to a CGatHost::PerformOperation() method,
    where the command is managed by a std::shared_ptr and also serves as a handle/reference point for the client
    so the client can query command status/progress at any time.  This pushes the burden of tracking operation
    parameters to the command object and provides a common reference point for both GatHost and its client.
    This is particularly nice because each command/param can publish its own signals.  *zang*
    Perhaps the commands would be renamed to xxxOp or xxxParam.
    Commands would need to use the GAT I/O thread synchronization doamin (guard) when they are passed to GatHost,
    but they can use their own when they are not scheduled or in progress.  Be careful to ensure that neither domain
    is locked when the active domain is changed!
[-] GetComponentCmd is virtually identical to GetFileCmd.  The only difference is the signals that are sent.
    This difference can be eliminted when commands are converted into arguments to GatHost::performOperation().
[x] Complete implementation of 'MainWindow::on_actionGetSpecialFunctions_triggered()'.
    Probably best to create a wrapper for 'GatHostGetSpecialFunctionsCmd', or subclass it, to handle
    when the command is complete and perform the appropriate activity with its results.
[x] Implement 'GatMultipktRply' to handle GAT responses composed of more than one packet.
    Add an instance of 'GatMultipktRply' to each 'GatHostCmd' derivative that implements a GAT
    operation with [possibly] more than one reply packet and have the command delegate replies from the
    link layer to the 'GatMultipktRply' instance.  The command should accumulate results and signal
    that a complete reply is available when it is.  'GatMultipktRply' should implement the multi-packet
    reply state machine.
    -------------------------------------------------------------------------------------------------------------
    OK, there is some confusion here.  IACQ(0x04)/IACR(0x84) are used to start an authorization request.
    The reply from the GM (IACR 0x84) is _short_.  If IACR reports that the authorization request has been
    started (or is pending) then LARQ(0x03)/LARR(0x83) are used to obtain it.  LARR is a long (multi-packet)
    response.  However, the GAT host must wait for the results to become ready before sending LARQ or else
    LARQ will reply with "Error" because no data is ready (yet).  The GAT host polls the ready state of the
    data from the authentication request with SQ(0x01)/SR(0x81).
[x] Implement another state machine that sends IACQ(0x04)/IACR(0x84),
    polls for data ready with SQ(0x01)/SR(0x81), and finally retrieves the data with LARQ(0x03)/LARR(0x83).
    [x] Implement all special functions with this.
[x] Verify that multi-packet logic checks GatLinkLayer::resultType() and doesn't just assume the packet is good.
[x] Implement support for (usage of) 'GatHostCmd' (as SQ 0x01) in 'MainWindow' to provide at least one
    functional example and to verify that everything works.
[x] Implement support for Last Authentication Status Request (LASQ 0x02) in 'MainWindow'.
[x] Implement support for (usage of) 'GatHostGetSpecialFunctionsCmd' in 'MainWindow' to provide at least one
    functional example and to verify that everything works.  'Get Special Functions' special function is working.
[x] Add support for MT state requirement: "Get File ProgramID.xml".
[x] BUG: Link layer is not properly responding to NAK to Get File command.
[x] BUG: Incorrect auth argument is being sent for "Get File ProgramID.xml".
[x] Add double-click support to special functions grid view to send any listed special function.
[x] Add menu item to support sending selected special function in special functions grid view.
[x] BUG: 'Q_ASSERT(timer_.isActive());' @ GatSpecialFunctionExec.cpp[275] is asserting sometimes (usually while debugging).
         Trigger this by executing "Get File" and prevent the GM from responding by setting a breakpoint in
         'GatCmd_GetFile::executeInCtx(GatCmdThread&)'.
[x] Need an I/O traffic tab (or perhaps a small view at the bottom of the window).  This requires a scrolling text view with a line limit.
[x] Need a TRACE/Log view tab.  This requires a scrolling text view with a line limit.
[x] Disable ability to resize the window.
[x] Add dialog box to prompt user for values of arguments that match regex "%%[^%]*%%", e.g. "%%SHA1_HMAC%%".
    Make sure it's possible for the user to specify nothing,
    thus eliminating the parameter (and all subsequent parameters).
    !!! ATTENTION !!!  This is currenly disabled in 'MainWindow::on_actionGetComponent_triggered()'.
[x] Is there no RxD inter-byte timeout to detect when a TX from the GM is complete?  There is now.
[ ] Stop using Ctrl+{C,A,X,V} for accelerators since those are edit controls.
[ ] Add menu item to send manually entered special function.
    Keep a MRU for the last 10 special functions entered.  Store in application config file in user's home directory.
[ ] Add additional states to commands so the main window knows why failure, e.g. timeout or CRC, not just failure.
[ ] Implement a state machine that polls the GM for SQ(0x01)/SR(0x81) when it is first opened to determine its
    version ID and current calcualtion status (update window GAT state indicators), and supported data formats.
    GAT USER OPERATIONS MUST BE BLOCKED UNTIL AFTER THE INITIAL STATUS IS RECEIVED AND
    THE GM IS DETERMINED TO BE COMPATIBLE WITH THE GAT HOST!
[ ] Verify that 'return QString().append(<QString_object_instance>);' clones and does *not* simply share a reference.
[ ] Verify that signals are automatically disconnected from slots when either side is destroyed.

--------- --------- --------- --------- --------- --------- --------- --------- --------- --------- --------- ---------

> All serial I/O is done on a seperate thread by GatHost.  The instance of GatHost is 'pushed' from the
  main window thread to the OS thread it implementes in GatHost::Startup(), as per the Qt rules.
> If all GatHostCmd operations are to be executed in the context of the GatHost thread, then they too
  must be pushed from the main window thread to the OS thread implemented by GatHost when they are scheduled.

--------- --------- --------- --------- --------- --------- --------- --------- --------- --------- --------- ---------

* MainWindow instantiates a GatSpecialFunctionsCmd and passes it to GatHost::schedule().
* GatHost queues the command and posts a 'LocalEventType::CmdQueueChanged' message to
  itself to trigger command queue processing.  Note that GatHost is derived from QThread
  and its local events are processed within its run() method's event loop.
[ ] Verify that events are *NOT* processed on the main thread!
[ ] !!! IS THIS ASYNCHRONOUS AS EXPECTED? !!!
* GatHost receives a 'LocalEventType::CmdQueueChanged' message and makes the queued
  instance of GatSpecialFunctionsCmd into the command in progress and calls it's begin() method.
* GatHostSpecialFxnCmd::begin() calls GatSpecialFunctionExec::sendRequest(), which creates
  the authentication request for the GAT Initiate Authentication Calculation Query (IACQ 0x04) and
  sends it via the GatLinkLayer::sendRequest().
* GatLinkLayer::sendRequest() serializes the packet data and transmits it via its strategy.
* GatHostSpecialFxnCmd() sends a signal for the command state change to 'CmdState::started',
  which is received and ignored by

(((Timeout Secenario)))

* GatLinkLayer::onTimer() is eventually called after no valid packet arrives, which calls
  GatLinkLayer::receiveTimeout().
* GatLinkLayer::receiveTimeout() calls GatLinkLayer::setState(State::Timeout) and
  then GatLinkLayer::setState(State::Ready) before returning, which both /synchronously/
  send events to its observers: GatLinkLayer, GatSpecialFunctionExec, and GatMultipktRply.
[ ] Verify that this is synchronous!


End of document.
